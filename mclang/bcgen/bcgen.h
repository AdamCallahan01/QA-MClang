
#ifndef __BCGEN_H__
#define __BCGEN_H__

#include "bcgen/context.h"
#include "bcgen/funcman.h"
#include "bcgen/instr.h"
#include "bcgen/return.h"
#include "bcgen/tmpvar.h"
#include "general/funcdef.h"
#include "general/types.h"
#include <string>
#include <vector>

class Compiler;
class FuncNode;
class Parser;

/**
 * Instructions are stored in functions which can then call each other
 */
struct BCFunc {
    BCFunc(std::string name);
    std::string name;
    std::vector<BCInstr> instrList;
};

/**
 * Manager object to keep track of stuff while generating bytecode, which is
 * done by the parse node objects. This object also stores the generated
 * bytecode
 */
class BCManager {

public:

    /**
     * Constructor
     * @param comp The compiler component
     */
    BCManager(Compiler *comp);

    /**
     * Destructor
     */
    ~BCManager();

    /**
     * Generate bytecode
     * @note This function assumes that the parser generated a parse tree, which
     * is used in this function
     * @post Generated bytecode is stored in `funcList`
     */
    void generate();

    /**
     * Get all of the generated bytecode
     * @return A pointer to a vector containing the functions which contain
     * bytecode instructions
     */
    const std::vector<BCFunc *> *getBytecode() const;

    /**
     * Get a pointer to the function that is currently being written to
     * @return A pointer to the top function on the `funcStack`
     */
    BCFunc *curFunc() const;

    /**
     * Write an instruction to the current function
     * @param instr The instruction to be appended
     * @post An instruction is appended to the top function of the `funcStack`
     */
    void write(BCInstr instr);

    /**
     * Create a new function and add it to the function stack
     * @param name The name of the function (optional)
     * @note If no name is given, a unique number will be assigned
     */
    void addFunc(std::string name = "");

    /**
     * Remove the top function from the function stack
     * @param index The index of the function as counted from the top of the
     * stack (default is the top function)
     * @post The top element of the `funcStack` is removed, if there is any
     * @note The function will still be present in the `funcList`
     */
    void popFunc(unsigned int index = 0);

    /**
     * Get a pointer to the top function on the function stack
     * @return Top element of `funcStack`
     */
    BCFunc *topFunc() const;

    /**
     * Set the contents of the function stack
     * @param stack A vector of pointer to BCFuncs representing the function
     * stack
     * @post `funcStack` is set to the value of `stack`
     */
    void setFuncStack(std::vector<BCFunc *> stack);

    /**
     * Push an entry on the write stack
     * @param val The value to push onto the write stack
     * @post A new entry is added at the end of the write stack
     */
    void pushWriteStack(bool val);

    /**
     * Change the top entry of the write stack
     * @param val The new value of the top entry
     * @post The top entry is changed to the new value
     * @note If the write stack is empty, nothing happens
     */
    void setTopWriteStack(bool val);

    /**
     * Remove the top entry of the write stack
     * @post The top entry of the write stack is removed
     * @note If the write stack is empty, nothing happens
     */
    void popWriteStack();

    /**
     * Check if writing is enabled currently
     * @return A boolean indicating if there are zero `false` entries in the
     * write stack
     */
    bool canWrite() const;

    /**
     * Add a control flow check, which adds an instruction that checks if a
     * certain condition is met, and only moves on if the condition is met
     * @param cond The condition that has to be met, as a Minecraft "execute if"
     * subcommand, if none is given default to "score 0ret [scoreboard] 
     * matches 0"
     * @post A new top function is on the function stack
     */
    void controlFlowCheck(std::string cond = "");

    // Context stack
    ContextStack ctx;

    // Function manager
    FuncManager funcs;

    // Temporary variable manager
    TmpVarManager tmp;

    // The compiler component
    Compiler *comp;

    // Current return type and value
    Return ret;

    // Pointer to the current function being generated, may be null
    FuncNode *curFuncNode;

private:

    /**
     * Generate global variable initialization in the "load" function
     * Also generate the intialization of the special variables "0ret" and
     * "0retv"
     * @note If the "load" function does not exist yet, it is created
     * @note Instructions are prepended to the "load" function
     */
    void genGlobalVarInit();

    // List of functions that are generated
    std::vector<BCFunc *> funcList;

    // Function stack, which helps with adding instructions to the right
    // functions
    std::vector<BCFunc *> funcStack;

    // Counter to keep track of unique IDs/names assigned to functions
    unsigned int uniqueFuncId;

    // Write stack: Keeps track of wether or not output should be generated
    std::vector<bool> writeStack;

    // Number of "false" entries on the write stack
    unsigned int writeStackCount;

};

#endif